// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./CLTStakingPool.sol";
import "./CLTReward.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

contract SOCService {
    using SafeERC20 for IERC20;

    address public immutable rewardToken; // CLT token (mintable)
    address public immutable owner; // Dev/owner wallet

    uint256 public ticketCounter;

    struct Ticket {
        uint256 id;
        string title;
        address client;
        address analyst;
        uint256 rewardAmount;
        address stakingPool;
        bool isValidated;
    }

    mapping(uint256 => Ticket) public tickets;

    event TicketCreated(uint256 indexed id, address indexed client, uint256 rewardAmount, address stakingPool);
    event AnalystAssigned(uint256 indexed id, address indexed analyst);
    event TicketValidated(uint256 indexed id, address indexed analyst);
    event EmergencyWithdraw(address indexed token, uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == owner, "Not authorized");
        _;
    }

    constructor(address _rewardToken, address _owner) {
        require(_rewardToken != address(0), "Invalid reward token");
        require(_owner != address(0), "Invalid owner");
        rewardToken = _rewardToken;
        owner = _owner;
    }

    function createTicket(string calldata _title, uint256 cltAmount) external {
        require(cltAmount > 0, "CLT amount must be > 0");

        // Deploy a new staking pool with this contract as the reward distributor
        CLTStakingPool pool = new CLTStakingPool(rewardToken, address(this));

        // Transfer CLT from the client to the staking pool
        IERC20(rewardToken).safeTransferFrom(msg.sender, address(pool), cltAmount);

        tickets[ticketCounter] = Ticket({
            id: ticketCounter,
            title: _title,
            client: msg.sender,
            analyst: address(0),
            rewardAmount: cltAmount,
            stakingPool: address(pool),
            isValidated: false
        });

        emit TicketCreated(ticketCounter, msg.sender, cltAmount, address(pool));
        ticketCounter++;
    }

    function setAnalyst(uint256 ticketId, address analyst) external {
        Ticket storage ticket = tickets[ticketId];
        require(msg.sender == ticket.client, "Only client can assign analyst");
        require(ticket.analyst == address(0), "Analyst already assigned");
        require(analyst != address(0), "Invalid analyst address");

        ticket.analyst = analyst;
        emit AnalystAssigned(ticketId, analyst);
    }

    function validateTicket(uint256 ticketId) external {
        Ticket storage ticket = tickets[ticketId];
        require(msg.sender == ticket.analyst, "Only analyst can validate");
        require(!ticket.isValidated, "Ticket already validated");

        ticket.isValidated = true;

        // Mint bonus to analyst
        CLTReward(rewardToken).mint(ticket.analyst, 100 ether); // 100 CLT

        emit TicketValidated(ticketId, msg.sender);
    }

    function emergencyWithdraw(address token, uint256 amount) external onlyOwner {
        IERC20(token).safeTransfer(owner, amount);
        emit EmergencyWithdraw(token, amount);
    }
}
